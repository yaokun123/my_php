<?php
/**
 * Created by PhpStorm.
 * User: yaok
 * Date: 2019/3/4
 * Time: 下午4:27
 */


/**
 * 在多进程程序中，如果父进程先于子进程退出，那么子进程将会被init进程收养，成为init进程的子进程，这种进程被称为孤儿进程
 */


$ppid = posix_getpid();//记录父进程的进程号

for($i=0;$i<5;$i++){
    $pid = pcntl_fork();


    if ($pid == 0)
    {
        break; //由于子进程也会执行循环的代码，所以让子进程退出循环
    }
}


if ($ppid == posix_getpid()) {
    //父进程直接退出，它的子进程都会成为孤儿进程
    exit(0);
}else{
    //子进程
    for($i = 0; $i < 100; $i ++)
    {
        echo "子进程" . posix_getpid() . " 循环 $i ...\n";
        sleep(1);
    }
}



/**
 * 可以看到五个子进程的父进程号都是1了（说明已经被init进程收养），并且这时控制台不再被程序占用，子进程转到了后台运行，
 * 这种孤儿进程被init进程收养的机制是实现后面将要介绍的守护进程的必要条件之一。
 */



/**
 * 子进程还有一种状态叫僵尸进程，子进程结束时并不是完全退出，内核进程表中仍旧保有该进程的记录，
 * 这样做的目的是能够让父进程可以得知子进程的退出状态，以及子进程是自杀（调用exit或代码执行完毕）还是他杀（被信号终止），
 * 父进程可以调用pcntl_wait 或 pcntl_waitpid 方法来回收子进程（收尸），释放子进程占用的所有资源，并获得子进程的退出状态，
 * 如果父进程不做回收，则僵尸进程一直存在，如果这时父进程也退出了，则这些僵尸进程会被init进程接管并自动回收。
 *
 *
 * 对于linux系统来说，一个长时间运行的多进程程序一定要回收子进程，因为系统的进程资源是有限的，僵尸进程会让系统的可用资源减少。
 */

//见下一节